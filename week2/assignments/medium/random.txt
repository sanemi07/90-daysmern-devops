# Reading the Contents of a File (Async Experiment)

This exercise is meant to **observe how async tasks behave** in Node.js when the event loop is busy.
You will:

* Read a file asynchronously
* Run an expensive (CPU-heavy) operation
* Observe the order and timing of outputs

---

## 1. Setup

Create two files in the same folder:

```
experiment.js
sample.txt
```

Put **any text** inside `sample.txt`, for example:

```
Hello from the file!
This text is being read asynchronously.
```

---

## 2. Basic Async File Read

```js
const fs = require('fs');

console.log('Start');

fs.readFile('sample.txt', 'utf8', (err, data) => {
  if (err) {
    console.error(err);
    return;
  }
  console.log('File contents:');
  console.log(data);
});

console.log('End');
```

### Observe

* `Start` prints first
* `End` prints next
* File contents print **later**

This proves `readFile` is **asynchronous**.

---

## 3. Add an Expensive Operation

Now add a CPU-heavy task **after** the file read call:

```js
const fs = require('fs');

console.log('Start');

fs.readFile('sample.txt', 'utf8', (err, data) => {
  if (err) {
    console.error(err);
    return;
  }
  console.log('File contents:');
  console.log(data);
});

// Expensive operation
let sum = 0;
for (let i = 0; i < 1e9; i++) {
  sum += i;
}

console.log('Expensive operation done');
```

### Observe

* File contents will **not print immediately**
* The expensive loop **blocks the event loop**
* File callback waits until the loop finishes

---

## 4. Increase the Cost Gradually

Try changing the loop size:

```js
for (let i = 0; i < 1e8; i++) {}
for (let i = 0; i < 1e9; i++) {}
for (let i = 0; i < 2e9; i++) {}
```

### Observe

* The bigger the loop, the longer the delay
* Async does **not** mean parallel

---

## 5. Key Learning Points

* `fs.readFile` is async, but its callback runs on the **main thread**
* CPU-heavy tasks block the event loop
* Async I/O cannot interrupt synchronous code

---

## 6. Mental Model (Important)

> **Async tasks wait patiently**
> **Blocking code decides when they run**

If the event loop is busy, callbacks wait — even if the file is already read.

---

## 7. Optional Challenge

Try this:

* Move the expensive loop **inside** the callback
* Replace `readFile` with `readFileSync`
* Measure time using `console.time()` / `console.timeEnd()`

---

When you finish this, you’ll *feel* the event loop — not just understand
